import "HCISocket.thingml"

thing HCISocketProxyImpl includes HCISocketProxy, HCIControllerProxy
@c_header "
  #include <errno.h>
  #include <stdio.h>
  #include <sys/ioctl.h>
  #include <bluetooth/bluetooth.h>
  #include <bluetooth/hci.h>
  #include <bluetooth/hci_lib.h>
  #include <bluetooth/l2cap.h>
"
@c_global "
  void printBytes(int length, void *data) {
    uint8_t *bytes = data;
    int i;
    printf(\"BYTES: [\");
    for (i = 0; i < length; i++) {
      printf(\"%2.2X, \", bytes[i]);
    }
    printf(\"]\\n\");
  }
"
{
  property DevHandle : Int = -1

  /* Open the HCI socket and set some parameters */
  function OpenSocket()
  @SuppressWarnings "Call"
  do
    '
      // Find the device ID of address specified
      int device_id = hci_devid('&Device&');
      if (device_id < 0) {
        printf("[ERROR] Couldn\'t find device with address ");
        fflush(stdout);
        perror('&Device&');
        return;
      }
      // Open the device
      int handle = hci_open_dev(device_id);
      if (handle < 0) {
        perror("[ERROR] Couldn\'t open HCI socket");
        return;
      }
      // Set socket filters to give us all events from the Controller
      struct hci_filter filt;
      filt.type_mask = 0xFFFFFFFF;
      filt.event_mask[0] = 0xFFFFFFFF;
      filt.event_mask[1] = 0xFFFFFFFF;
      filt.opcode = 0x0000;
      if (setsockopt(handle, SOL_HCI, HCI_FILTER, &filt, sizeof(filt)) < 0) {
        perror("[ERROR] Couldn\'t set HCI socket filter");
        hci_close_dev(handle);
        return;
      }
      // Save the address for later use
      struct hci_dev_info info;
      if (hci_devinfo(device_id, &info) < 0) {
        perror("[WARNING] Couldn\'t get HCI device info");
      } else {
         memcpy(&'&Address&', &info.bdaddr, sizeof(bdaddr_t));
         if (info.type == 3) '&AddressType&' = 1;
         else '&AddressType&' = info.type;
      }
      // We are open for business
      '&DevHandle&' = handle;
      'StartSocketReader()'
    '
  end

  /* Close HCI socket */
  function CloseSocket()
  @SuppressWarnings "Call"
  do
    'hci_close_dev('&DevHandle&');'
  end

  /* Check if socket is open */
  function SocketIsOpen()
  @SuppressWarnings "Call"
  : Byte
  do
    return DevHandle >= 0
  end

  /* Get the address of the controller currently connected to */
  property Address : BTAddress
  property AddressType : Byte = 0
  
  function GetBTAddress()
  @SuppressWarnings "Call"
  : BTAddress
  do
    var AddressRet : BTAddress = '{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}'
    if (DevHandle >= 0) do
      AddressRet = Address
    end
    return AddressRet
  end

  /* Function to send data to the socket */
  function SendCommand(Group: UInt, Command: UInt, Length : Byte, Data: DataPointer )
  @SuppressWarnings "Call"
  do
    if (DevHandle >= 0) do
      '
        if (hci_send_cmd('&DevHandle&', '&Group&', '&Command&', '&Length&', '&Data&') < 0) {
          // Something went wrong, just close the socket and give up
          // It will eventually go into closed state and inform others
          hci_close_dev('&DevHandle&');
          '&DevHandle&' = -1;
        }
      '
    end
  end

  /* Function to send ACL data to the socket */
  function SendACLData(Handle : UInt, CID : UInt, Length : UInt, Data : DataPointer)
  @SuppressWarnings "Call"
  do
    if (DevHandle >= 0) do
      '
        uint8_t buffer[HCI_MAX_ACL_SIZE];
        buffer[0] = HCI_ACLDATA_PKT;
        *((uint16_t*)&buffer[1]) = '&Handle&' & 0x0FFF;
        *((uint16_t*)&buffer[3]) = '&Length&' + 4;
        *((uint16_t*)&buffer[5]) = '&Length&';
        *((uint16_t*)&buffer[7]) = '&CID&';
        memcpy(&buffer[9], '&Data&', '&Length&');

        while (write('&DevHandle&', buffer, '&Length&'+9) < 0) {
          if (errno == EAGAIN || errno == EINTR)
            continue;

          hci_close_dev('&DevHandle&');
          '&DevHandle&' = -1;
        }

      '
    end
  end

  /* Function to read data from the socket */
  function StartSocketReader()
  @fork_linux_thread "true"
  do
    var MessageType : Byte
    // Events
    var EventType : Byte
    var Length : Byte
    // ACL Data
    var Handle : UInt
    var PacketBoundary : ACLPacketBoundaryFlag
    var Broadcast : ACLBroadcastFlag
    var LLength : UInt
    // Shared
    var Data : DataPointer
    '
      int bytes_read = 0;
      uint8_t buffer[HCI_MAX_FRAME_SIZE];
    '
    while (DevHandle >= 0) do
      '
        bytes_read = read('&DevHandle&', buffer, HCI_MAX_FRAME_SIZE);
        if (bytes_read < 0) {
          if (errno == EAGAIN || errno == EINTR) {
            usleep(1);
          } else {
            // Something went wrong, just close the socket and give up
            // It will eventually go into closed state and inform others
            hci_close_dev('&DevHandle&');
            '&DevHandle&' = -1;
            return;
          }
        } else {
          // Decode packet and send appropriate messages
          '&MessageType&' = buffer[0];
          switch ('&MessageType&') {
            case 0x01: // HCI Command
              //printf("[WARNING]: Unhandled incoming HCI command!\n");
              //TODO: Jakob - why does this even happen??
              break;
            case 0x02: // ACL Data
              '&Handle&' = *((uint16_t*)&buffer[1]) & 0x0FFF;
              '&PacketBoundary&' = (buffer[2] & 0x30) >> 4;
              '&Broadcast&' = (buffer[2] & 0xC0) >> 6;
              '&LLength&' = *((uint16_t*)&buffer[3]);
              '&Data&' = &buffer[5];
              'HandleACLData(Handle, PacketBoundary, Broadcast, LLength, Data)'
              break;
            case 0x03: // SCO Data
              printf("[WARNING]: Unhandled incoming SCO data!\n");
              break;
            case 0x04: // HCI Event 
              '&EventType&' = buffer[1];
              '&Length&' = buffer[2];
              '&Data&' = &buffer[3];
              'KernelDisconnectHack(EventType, Length, Data)'
              'DecodeEvent(EventType, Length, Data)'
              break;
            case 0xff: // Vendor Package
              printf("[WARNING]: Unhandled incoming vendor package!\n");
              break;
          }
        }
      '
    end
  end
  
  /* Hacks for keeping the kernel from closing connections prematurely */
  /* See: https://github.com/sandeepmistry/node-bluetooth-hci-socket/blob/master/src/BluetoothHciSocket.cpp#L319 */
  property KernelSocket : CInt = 0
  function KernelDisconnectHack(Event : Byte, Length : Byte, Data : DataPointer) do
    if (Event == '0x3E' and ''&Data&'[0]' == '0x01' and ''&Data&'[1]' == '0x00') do // LE Meta Event - LE Connection Complete, Status 0x00
      /* Create an L2CAP socket */
      '
        int l2socket = socket(PF_BLUETOOTH, SOCK_SEQPACKET, 0);
        struct sockaddr_l2 l2a;
        if (l2socket == -1) {
          perror("[WARNING]: Could not create kernel-hack socket");
          return;
        }
        
        unsigned short l2cid;
#if __BYTE_ORDER == __LITTLE_ENDIAN
        l2cid = 4;
#elif __BYTE_ORDER == __BIG_ENDIAN
        l2cid = bswap_16(4);
#else
        #error "Unknown byte order"
#endif
        
        memset(&l2a, 0, sizeof(l2a));
        l2a.l2_family = AF_BLUETOOTH;
        l2a.l2_cid = l2cid;
        memcpy(&l2a.l2_bdaddr, &'&Address&', sizeof(l2a.l2_bdaddr));
        l2a.l2_bdaddr_type = '&AddressType&';
      
        printBytes(6, &l2a.l2_bdaddr);
        printBytes(2, &l2a.l2_cid);
        printBytes(1, &l2a.l2_bdaddr_type);
        
        if (bind(l2socket, (struct sockaddr*)&l2a, sizeof(l2a)) < 0) {
          perror("[WARNING]: Could not bind kernel-hack socket");
          return;
        }
        
        memset(&l2a, 0, sizeof(l2a));
        l2a.l2_family = AF_BLUETOOTH;
        l2a.l2_cid = l2cid;
        memcpy(&l2a.l2_bdaddr, &'&Data&'[6], sizeof(l2a.l2_bdaddr));
        l2a.l2_bdaddr_type = '&Data&'[5] + 1;
        
        printBytes(6, &l2a.l2_bdaddr);
        printBytes(2, &l2a.l2_cid);
        printBytes(1, &l2a.l2_bdaddr_type);
        
        if (connect(l2socket, (struct sockaddr*)&l2a, sizeof(l2a)) < 0) {
          perror("[WARNING]: Could not connect kernel-hack socket");
          return;
        }
        
        '&KernelSocket&' = l2socket;
      '
    end
    
    if (Event == '0x05' and ''&Data&'[0]' == '0x00') do // Disconnection Complete, Status 0x00
      /* Delete the L2CAP socket */
      '
        if ('&KernelSocket&' != 0 && close('&KernelSocket&') < 0) {
          perror("[WARNING]: Could not close kernel-hack socket");
        }
        '&KernelSocket&' = 0;
      '
    end
    
    // TODO: Jakob handle multiple connections based on handle?
  end
}
