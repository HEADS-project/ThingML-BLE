import "ExitHandler.thingml"
import "BLE_initialiser.thingml"
import "BLE_connecter.thingml"
import "BLE_bloodpressure.thingml"
import "BLE_notifier.thingml"
import "HCISocketImpl.thingml"

protocol MQTT @serializer "PosixJSONSerializerPlugin" @mqtt_broker_address "10.218.149.140" @mqtt_topic "ThingML" @trace_level "2" @mqtt_will "{ \"ERROR\": \"Unexpected disconnect\" }"

thing fragment MqttMsgs
{
  message MqttBloodPressureMeasurement(Systolic : Float, Diastolic : Float, MeanArterial : Float, UnitKPA : Boolean, Year : UInt, Month : Byte, Day : Byte, Hour : Byte, Minute : Byte, Second : Byte, Pulse : Float, IrregularPulse : Boolean);
  message MqttRequestBloodPressureMeasurement();
  message MqttConfirmBloodPressureMeasurement();
}

thing Main includes BLEInitialiser, BLEBloodpressure, BLENotifier, ExitHandlerMsgs, BLEConnecterMsgs, MqttMsgs
{
  required port Signals {
    receives Interrupt
    sends Quit
  }

  /* Connecter instances for Blood Pressure device and LED Notifier device */
  required port BloodPressureDevice
  {
    sends Connect, Stop, Encrypt
    receives Connected, Stopped, Failure, Encrypted
  }
  required port NotifierDevice
  {
    sends Connect, Stop, Encrypt
    receives Connected, Stopped, Failure, Encrypted
  }

  /* MQTT messages */
  required port Gateway
  {
    sends MqttBloodPressureMeasurement
    receives MqttRequestBloodPressureMeasurement, MqttConfirmBloodPressureMeasurement
  }

  property SendToNotifier : Byte = '0x00'

  statechart States init Initialise
  {
    // Initialise HCI socket and BLE controller
    state Initialise
    {
      on entry Initialiser!Start()

      transition -> Standby event Initialiser?DeviceInitialised

      transition -> Failed event Initialiser?Failure
      transition -> Quit event Signals?Interrupt
    }

    // Main logic
    composite state Standby init SyncBloodPressure
    {
      composite state SyncBloodPressure init ConnectBP
      {
        state ConnectBP
        {
          on entry do
            print "[INFO]: Connecting to Blood Pressure Monitor...\n"
            BloodPressureDevice!Connect()
          end

          transition -> ConnectedBP event BloodPressureDevice?Encrypted
        }

        state ConnectedBP
        {
          internal event e:Bloodpressure?BloodPressureMeasurement action do
            Gateway!MqttBloodPressureMeasurement(e.Systolic, e.Diastolic, e.MeanArterial, e.UnitKPA, e.Year, e.Month, e.Day, e.Hour, e.Minute, e.Second, e.Pulse, e.IrregularPulse)
          end

          transition -> ConnectBP event BloodPressureDevice?Stopped guard (SendToNotifier == '0x00') action do
            print "[INFO]: Finished syncing with Blood Pressure Monitor.\n"
            // TODO Add a small delay here maybe?
          end
        }

        internal event e:Gateway?MqttRequestBloodPressureMeasurement action do
          SendToNotifier = '0x01'
          BloodPressureDevice!Stop()
        end
        
        internal event e:Gateway?MqttConfirmBloodPressureMeasurement action do
          SendToNotifier = '0x02'
          BloodPressureDevice!Stop()
        end

        transition -> SendToNotifier event BloodPressureDevice?Stopped guard (SendToNotifier != '0x00')
      }

      
      composite state SendToNotifier init ConnectN
      {
        state ConnectN
        {
          on entry do
            print "[INFO]: Connecting to Notifier ...\n"
            NotifierDevice!Connect()
          end

          transition -> ConnectedN event Notifications?ReadyForNotificationCommand
        }

        state ConnectedN
        {
          on entry do
            if (SendToNotifier == '0x01') do
              Notifications!RequestBloodPressureMeasurement()
            end
            if (SendToNotifier == '0x02') do
              Notifications!ConfirmBloodPressureMeasurement()
            end
            SendToNotifier = '0x00'
          end
        }

        transition -> SyncBloodPressure event NotifierDevice?Stopped
        transition -> SyncBloodPressure event NotifierDevice?Failure
      }

      transition -> Deinitialise event Signals?Interrupt
      transition -> Failed event Initialiser?Failure
    }

    // Close everything
    state Deinitialise
    {
      on entry do
        print "[INFO]: Stopping...\n"
        BloodPressureDevice!Stop()
      end

      internal event BloodPressureDevice?Stopped action NotifierDevice!Stop()
      internal event NotifierDevice?Stopped action Initialiser!Stop()

      transition -> Quit event Initialiser?Stopped

      transition -> Failed event BloodPressureDevice?Failure
      transition -> Failed event NotifierDevice?Failure
      transition -> Failed event Initialiser?Failure

      transition -> Failed event Signals?Interrupt
    }

    // Failed somewhere
    state Failed
    {
      on entry do
        print "[ERROR]: Failed, quitting... !!!\n"
        Signals!Quit(1)
      end
    }

    // Normal QUIT
    state Quit // TODO How do we want to quit?
    {
      on entry do
        print "[INFO]: Finished, quitting...\n"
        Signals!Quit(0)
      end
    }
  }
}

configuration AND_UA651BLE_SYNC
@add_c_libraries "bluetooth"
@c_header "
  /*
  // Jakobs device
  ble_random_number_t peer_ltk = { 0x33, 0x46, 0xCC, 0x17, 0x3F, 0x56, 0xBC, 0x52, 0xF4, 0xB2, 0x90, 0xC4, 0x0E, 0xEF, 0x43, 0x05, };
  uint16_t peer_ediv = 0xF7B3;
  ble_random_part_t peer_random = { 0xD0, 0xC4, 0x4A, 0x1F, 0x57, 0x36, 0xF2, 0xBC, };
  */
  // Francks device
  ble_random_number_t peer_ltk = { 0x92, 0x3D, 0xDD, 0x2F, 0xE9, 0x9A, 0x16, 0xCD, 0x95, 0xCC, 0x2D, 0x6C, 0xEA, 0x9E, 0x86, 0x0D, };
  uint16_t peer_ediv = 0xD820;
  ble_random_part_t peer_random  = { 0xE9, 0x9A, 0xF6, 0x4D, 0x93, 0xC4, 0xCD, 0xEC, };
  
  notifier_cmd_t request_cmd = { 2, '!', 'N' };
  notifier_cmd_t confirm_cmd = { 2, '!', 'S' };
"
{
  instance handler : ExitHandler
  instance hci     : HCISocketProxyImpl

  instance main : Main

  instance initialiser            : BLEInitialiserImpl
  instance connecterbloodpressure : BLEConnecterImpl
  instance connecternotifier      : BLEConnecterImpl
  instance bloodpressure          : BLEBloodpressureImpl
  instance notifier               : BLENotifierImpl



  connector main.Signals => handler.Signals
  connector main.Initialiser => initialiser.Initialiser
  connector main.BloodPressureDevice => connecterbloodpressure.Connecter
  connector main.Bloodpressure => bloodpressure.Bloodpressure
  connector main.NotifierDevice => connecternotifier.Connecter
  connector main.Notifications => notifier.Notifications
  connector main.Gateway over MQTT

  connector initialiser.Socket => hci.Socket
  connector initialiser.HCICommands => hci.Commands
  connector initialiser.HCIEvents => hci.Events

  connector connecterbloodpressure.Socket => hci.Socket
  connector connecterbloodpressure.HCICommands => hci.Commands
  connector connecterbloodpressure.HCIEvents => hci.Events

  connector connecternotifier.Socket => hci.Socket
  connector connecternotifier.HCICommands => hci.Commands
  connector connecternotifier.HCIEvents => hci.Events

  connector bloodpressure.ATT => hci.ATT
  connector bloodpressure.Connecter => connecterbloodpressure.Connecter

  connector notifier.ATT => hci.ATT
  connector notifier.Connecter => connecternotifier.Connecter



  set hci.Device = "B8:27:EB:03:FA:CD"
  //set hci.Device = "B8:27:EB:F1:1D:FF"
  
  set connecterbloodpressure.ConnectAddressType = BLEAddressType:PUBLIC
  //set connecterbloodpressure.ConnectAddress = "5C:31:3E:03:54:2F" //Jakob
  set connecterbloodpressure.ConnectAddress = "5C:31:3E:00:4B:6B" //Franck
  set connecterbloodpressure.LongTermKey = 'peer_ltk'
  set connecterbloodpressure.EncryptedDiversifier = 'peer_ediv'
  set connecterbloodpressure.RandomNumber = 'peer_random'

  set connecternotifier.ConnectAddressType = BLEAddressType:RANDOM
  //set connecternotifier.ConnectAddress = "C7:BD:03:2B:88:33"
  set connecternotifier.ConnectAddress = "F3:48:7F:62:B8:60"
  
  set notifier.RequestCommand = 'request_cmd'
  set notifier.ConfirmCommand = 'confirm_cmd'
}
